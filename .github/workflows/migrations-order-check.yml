name: Проверка порядка миграций

on:
  pull_request:
    types: [opened, synchronize, reopened, ready_for_review]

permissions:
  contents: read

jobs:
  check:
    runs-on: ubuntu-latest
    steps:
      - name: Получить код репозитория
        uses: actions/checkout@v4
        with:
          fetch-depth: 1
          ref: ${{ github.event.pull_request.head.sha }}

      - name: Определить, есть ли новые SQL-миграции
        id: mig
        shell: bash
        env:
          BASE_SHA: ${{ github.event.pull_request.base.sha }}
          HEAD_SHA: ${{ github.event.pull_request.head.sha }}
        run: |
          set -euo pipefail
          git fetch origin "$BASE_SHA" --depth=1

          python3 - <<'PY'
          import os
          import subprocess

          base = os.environ["BASE_SHA"]
          head = os.environ["HEAD_SHA"]

          diff = subprocess.check_output(
              ["git", "diff", "--name-status", f"{base}..{head}"],
              text=True
          ).splitlines()

          run = False
          for line in diff:
              parts = line.split("\t")
              if len(parts) >= 2 and parts[0] == "A":
                  path = parts[1].rstrip()
                  if path.startswith("migrations/") and path.endswith(".sql"):
                      run = True
                      break

          with open(os.environ["GITHUB_OUTPUT"], "a", encoding="utf-8") as f:
              f.write(f"run={'true' if run else 'false'}\n")
          PY

      - name: Пропуск (если новых SQL-миграций нет)
        if: steps.mig.outputs.run != 'true'
        run: echo "Новых SQL-миграций нет — проверка не требуется."

      - name: Проверить формат имён новых миграций
        if: steps.mig.outputs.run == 'true'
        shell: bash
        env:
          BASE_SHA: ${{ github.event.pull_request.base.sha }}
          HEAD_SHA: ${{ github.event.pull_request.head.sha }}
        run: |
          set -euo pipefail
          git fetch origin "$BASE_SHA" --depth=1

          python3 - <<'PY'
          import os
          import re
          import subprocess
          import sys

          base = os.environ["BASE_SHA"]
          head = os.environ["HEAD_SHA"]

          # Новый строгий формат (18 цифр до "_"):
          # <YY><Major(месяц 01-12)><Minor(2)><Hotfix(2)><MM(01-12)><DD><HH><mm><ss>_desc.sql
          strict_name_regex = re.compile(
              r"^(?P<yy>\d{2})"
              r"(?P<major>(0[1-9]|1[0-2]))"
              r"(?P<minor>\d{2})"
              r"(?P<hf>\d{2})"
              r"(?P<MM>(0[1-9]|1[0-2]))"
              r"(?P<DD>(0[1-9]|[12]\d|3[01]))"
              r"(?P<HH>([01]\d|2[0-3]))"
              r"(?P<mm>([0-5]\d))"
              r"(?P<ss>([0-5]\d))"
              r"_.+\.sql$"
          )

          def fail(msg: str):
              print(f"::error::{msg}")
              sys.exit(1)

          diff = subprocess.check_output(
              ["git", "diff", "--name-status", f"{base}..{head}"],
              text=True
          ).splitlines()

          added_sql = []
          for line in diff:
              parts = line.split("\t")
              if len(parts) >= 2 and parts[0] == "A":
                  path = parts[1].rstrip()
                  if path.startswith("migrations/") and path.endswith(".sql"):
                      added_sql.append(path)

          if not added_sql:
              print("OK")
              sys.exit(0)

          bad = []
          month_mismatch = []
          prefixes = {}

          for path in added_sql:
              name = os.path.basename(path)

              m = strict_name_regex.match(name)
              if not m:
                  bad.append(name)
                  continue

              # Раз major = месяц — требуем совпадения major и MM
              if m.group("major") != m.group("MM"):
                  month_mismatch.append(f"{name} (major={m.group('major')}, MM={m.group('MM')})")

              # Дубликаты среди новых: одинаковые цифры до "_"
              pref = name.split("_", 1)[0]
              prefixes[pref] = prefixes.get(pref, 0) + 1

          if bad:
              fail(
                  "Новые миграции должны соответствовать формату: "
                  "<YY><Major(месяц 01-12)><Minor(2)><Hotfix(2)><MM><DD><HH><mm><ss>_desc.sql. Ошибки: " +
                  ", ".join(bad[:20]) + ("..." if len(bad) > 20 else "")
              )

          if month_mismatch:
              fail(
                  "В новых миграциях поле Major(месяц) должно совпадать с MM. Ошибки: " +
                  ", ".join(month_mismatch[:20]) + ("..." if len(month_mismatch) > 20 else "")
              )

          dups = [p for p, c in prefixes.items() if c > 1]
          if dups:
              fail(
                  "Найдены дубликаты версий среди новых миграций в PR (одинаковые цифры до '_'): " +
                  ", ".join(sorted(dups)[:20])
              )

          print("OK")
          PY
