name: Проверка порядка миграций

on:
  pull_request:
    types: [opened, synchronize, reopened, ready_for_review]

permissions:
  contents: read

jobs:
  check:
    runs-on: ubuntu-latest
    steps:
      - name: Получить код репозитория
        uses: actions/checkout@v4
        with:
          fetch-depth: 1
          ref: ${{ github.event.pull_request.head.sha }}

      - name: Определить, есть ли новые SQL-миграции
        id: mig
        shell: bash
        env:
          BASE_SHA: ${{ github.event.pull_request.base.sha }}
          HEAD_SHA: ${{ github.event.pull_request.head.sha }}
        run: |
          set -euo pipefail
          git fetch origin "$BASE_SHA" --depth=1

          python3 - <<'PY'
          import os, subprocess

          base = os.environ["BASE_SHA"]
          head = os.environ["HEAD_SHA"]

          diff = subprocess.check_output(
              ["git", "diff", "--name-status", f"{base}..{head}"],
              text=True
          ).splitlines()

          run = False
          for line in diff:
              parts = line.split("\t")
              if len(parts) >= 2 and parts[0] == "A":
                  path = parts[1].rstrip()
                  if path.startswith("migrations/") and path.endswith(".sql"):
                      run = True
                      break

          with open(os.environ["GITHUB_OUTPUT"], "a", encoding="utf-8") as f:
              f.write(f"run={'true' if run else 'false'}\n")
          PY

      - name: Пропуск (если новых SQL-миграций нет)
        if: steps.mig.outputs.run != 'true'
        run: echo "Новых SQL-миграций нет — проверка не требуется."

      - name: Проверить формат и порядок новых миграций
        if: steps.mig.outputs.run == 'true'
        shell: bash
        env:
          BASE_SHA: ${{ github.event.pull_request.base.sha }}
          HEAD_SHA: ${{ github.event.pull_request.head.sha }}
        run: |
          set -euo pipefail
          git fetch origin "$BASE_SHA" --depth=1

          python3 - <<'PY'
          import os
          import re
          import subprocess
          import sys

          base = os.environ["BASE_SHA"]
          head = os.environ["HEAD_SHA"]

          # Новый строгий формат (18 цифр до "_"):
          # <YY><Major(месяц 01-12)><Minor(2)><Hotfix(2)><MM(01-12)><DD><HH><mm><ss>_desc.sql
          strict_name_regex = re.compile(
              r"^(?P<yy>\d{2})"
              r"(?P<major>(0[1-9]|1[0-2]))"
              r"(?P<minor>\d{2})"
              r"(?P<hf>\d{2})"
              r"(?P<MM>(0[1-9]|1[0-2]))"
              r"(?P<DD>(0[1-9]|[12]\d|3[01]))"
              r"(?P<HH>([01]\d|2[0-3]))"
              r"(?P<mm>([0-5]\d))"
              r"(?P<ss>([0-5]\d))"
              r"_.+\.sql$"
          )

          def fail(msg: str):
              print(f"::error::{msg}")
              sys.exit(1)

          def version_from_name(name: str):
              m = strict_name_regex.match(name)
              if not m:
                  return None, None
              # Версия = цифры до "_"
              v = int(name.split("_", 1)[0])
              # Раз major = месяц — требуем совпадения major и MM
              if m.group("major") != m.group("MM"):
                  return v, f"major={m.group('major')} != MM={m.group('MM')}"
              return v, None

          # 1) список ДОБАВЛЕННЫХ sql в migrations/ в PR
          diff = subprocess.check_output(
              ["git", "diff", "--name-status", f"{base}..{head}"],
              text=True
          ).splitlines()

          added_sql = []
          for line in diff:
              parts = line.split("\t")
              if len(parts) >= 2 and parts[0] == "A":
                  path = parts[1].rstrip()
                  if path.startswith("migrations/") and path.endswith(".sql"):
                      added_sql.append(path)

          if not added_sql:
              print("OK")
              sys.exit(0)

          # 2) базовые версии (НЕ валидируем base по формату — просто берем те, что совпадают)
          base_paths = subprocess.check_output(
              ["git", "ls-tree", "-r", "--name-only", base, "--", "migrations"],
              text=True
          ).splitlines()

          base_versions = set()
          base_max = -1
          for p in base_paths:
              if not p.endswith(".sql"):
                  continue
              name = os.path.basename(p)
              v, _ = version_from_name(name)
              if v is None:
                  continue  # legacy/прочее в base игнорируем, не падаем
              base_versions.add(v)
              if v > base_max:
                  base_max = v

          # 3) проверяем имена новых + дубликаты среди новых + порядок относительно base_max
          bad = []
          month_mismatch = []
          prefixes = {}
          offenders = []

          for path in added_sql:
              name = os.path.basename(path)

              v, mismatch = version_from_name(name)
              if v is None:
                  bad.append(name)
                  continue
              if mismatch:
                  month_mismatch.append(f"{name} ({mismatch})")

              pref = name.split("_", 1)[0]
              prefixes[pref] = prefixes.get(pref, 0) + 1

              if v in base_versions:
                  offenders.append(f"{name} (версия уже существует в целевой ветке)")
              if base_max != -1 and v <= base_max:
                  offenders.append(f"{name} (версия {v} <= max(base) {base_max})")

          if bad:
              fail(
                  "Новые миграции должны соответствовать формату: "
                  "<YY><Major(месяц 01-12)><Minor(2)><Hotfix(2)><MM><DD><HH><mm><ss>_desc.sql. Ошибки: " +
                  ", ".join(bad[:20]) + ("..." if len(bad) > 20 else "")
              )

          if month_mismatch:
              fail(
                  "В новых миграциях поле Major(месяц) должно совпадать с MM. Ошибки: " +
                  ", ".join(month_mismatch[:20]) + ("..." if len(month_mismatch) > 20 else "")
              )

          dups = [p for p, c in prefixes.items() if c > 1]
          if dups:
              fail(
                  "Найдены дубликаты версий среди новых миграций в PR (одинаковые цифры до '_'): " +
                  ", ".join(sorted(dups)[:20])
              )

          if offenders:
              fail(
                  "Новые миграции должны иметь версию строго больше существующих в целевой ветке. Нарушители: " +
                  ", ".join(offenders[:20]) + ("..." if len(offenders) > 20 else "")
              )

          print("OK")
          PY
