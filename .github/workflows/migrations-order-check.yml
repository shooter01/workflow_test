name: Проверка порядка миграций

on:
  pull_request:
    types: [opened, synchronize, reopened, ready_for_review]

permissions:
  contents: read

jobs:
  check:
    runs-on: ubuntu-latest
    steps:
      - name: Получить код репозитория (полная история)
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          # чтобы HEAD был именно PR-веткой, а не merge-commit
          ref: ${{ github.event.pull_request.head.sha }}

      - name: Определить, менялись ли миграции
        id: mig
        shell: bash
        run: |
          set -euo pipefail
          git fetch origin "${{ github.base_ref }}" --depth=1
          if git diff --name-only "origin/${{ github.base_ref }}...HEAD" | grep -E '^migrations/.*\.sql$' >/dev/null; then
            echo "run=true" >> "$GITHUB_OUTPUT"
            echo "Migration changes detected"
          else
            echo "run=false" >> "$GITHUB_OUTPUT"
            echo "No migration changes"
          fi

      - name: Пропуск (если миграции не менялись)
        if: steps.mig.outputs.run != 'true'
        run: echo "✅ Миграции не менялись — проверка не требуется."

      - name: Проверить формат имён и порядок версий новых миграций
        if: steps.mig.outputs.run == 'true'
        shell: bash
        run: |
          python3 - <<'PY'
          import os
          import re
          import subprocess
          import sys

          MIGRATIONS_DIR = "migrations"

          version_prefix_regex = re.compile(r"^(?P<version>\d+)_.+\.sql$")

          strict_new_name_regex = re.compile(
              r"^(?P<yy>\d{2})(?P<major>\d{1,3})(?P<minor>\d{2})(?P<hf>\d{2})"
              r"(?P<MM>(0[1-9]|1[0-2]))(?P<DD>(0[1-9]|[12]\d|3[01]))(?P<HH>([01]\d|2[0-3]))"
              r"(?P<mm>([0-5]\d))(?P<ss>([0-5]\d))_.+\.sql$"
          )

          def run_and_capture(cmd):
              return subprocess.check_output(cmd, text=True).strip()

          def fail(message: str):
              print(f"::error::{message}")
              sys.exit(1)

          def list_sql_migrations(git_ref: str):
              cmd = ["git", "ls-tree", "-r", "--name-only", git_ref, "--", MIGRATIONS_DIR]
              paths = subprocess.check_output(cmd, text=True).splitlines()
              return [path for path in paths if path.endswith(".sql")]

          def parse_goose_version(file_path: str):
              migration_name = os.path.basename(file_path)
              match = version_prefix_regex.match(migration_name)
              if not match:
                  return None
              return int(match.group("version"))

          base_branch_name = os.environ.get("GITHUB_BASE_REF")
          if not base_branch_name:
              fail("Этот workflow предназначен для событий pull_request (GITHUB_BASE_REF пуст).")

          subprocess.check_call(["git", "fetch", "origin", base_branch_name, "--depth=1"])
          base_ref = f"origin/{base_branch_name}"

          head_sha = run_and_capture(["git", "rev-parse", "HEAD"])
          base_sha = run_and_capture(["git", "rev-parse", base_ref])
          print(f"DIAG: base_ref={base_ref} ({base_sha}), head={head_sha}")

          base_migrations = list_sql_migrations(base_ref)
          head_migrations = list_sql_migrations("HEAD")

          base_set = set(base_migrations)
          head_set = set(head_migrations)

          missing_in_pr = sorted(base_set - head_set)
          if missing_in_pr:
              fail(
                  "PR удаляет/переименовывает существующие миграции из целевой ветки: " +
                  ", ".join(missing_in_pr[:20]) + ("..." if len(missing_in_pr) > 20 else "")
              )

          new_migrations = sorted(head_set - base_set)
          if new_migrations:
              print("DIAG: new_files:")
              for file_path in new_migrations[:100]:
                  print(" -", os.path.basename(file_path))

          base_versions = []
          invalid_base_names = []
          for file_path in base_migrations:
              version = parse_goose_version(file_path)
              if version is None:
                  invalid_base_names.append(os.path.basename(file_path))
              else:
                  base_versions.append(version)

          if invalid_base_names:
              fail(
                  "Имя файла миграции в целевой ветке должно начинаться с цифр и затем содержать подчёркивание: " +
                  ", ".join(invalid_base_names[:10]) + ("..." if len(invalid_base_names) > 10 else "")
              )

          base_max_version = max(base_versions) if base_versions else -1
          print(f"DIAG: base_max={base_max_version}")

          bad_new_names = []
          for file_path in new_migrations:
              migration_name = os.path.basename(file_path)
              if not strict_new_name_regex.match(migration_name):
                  bad_new_names.append(migration_name)

          if bad_new_names:
              fail(
                  "Новые миграции должны соответствовать формату: <YY><Major(1-3)><Minor(2)><Hotfix(2)><MM><DD><HH><mm><ss>_desc.sql. Ошибки: " +
                  ", ".join(bad_new_names[:20]) + ("..." if len(bad_new_names) > 20 else "")
              )

          version_counts = {}
          for file_path in head_migrations:
              version = parse_goose_version(file_path)
              if version is None:
                  fail(
                      "Имя файла миграции должно начинаться с цифр и затем содержать подчёркивание: " +
                      os.path.basename(file_path)
                  )
              version_counts[version] = version_counts.get(version, 0) + 1

          duplicate_versions = [v for v, count in version_counts.items() if count > 1]
          if duplicate_versions:
              fail(
                  "Найдены дубликаты версий миграций в PR-ветке: " +
                  ", ".join(map(str, sorted(duplicate_versions)[:20]))
              )

          order_offenders = []
          for file_path in new_migrations:
              version = parse_goose_version(file_path)
              if version is None:
                  continue
              if version <= base_max_version:
                  order_offenders.append(f"{os.path.basename(file_path)} ({version})")

          if order_offenders:
              fail(
                  f"Версии новых миграций должны быть > max(base) ({base_max_version}). Нарушители: " +
                  ", ".join(order_offenders[:20]) + ("..." if len(order_offenders) > 20 else "")
              )

          print(f"OK. max(base)={base_max_version}, новых миграций={len(new_migrations)}")
          PY
