name: Проверка порядка миграций

on:
  pull_request:
    paths:
      - "migrations/**/*.sql"

jobs:
  check:
    runs-on: ubuntu-latest
    steps:
      - name: Получить код репозитория (полная история)2
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Проверить формат имён и порядок версий новых миграций
        shell: bash
        run: |
          python3 - <<'PY'
          import os, re, subprocess, sys

          MIG_DIR = "migrations"

          # Общий префикс: цифры до "_" (goose-версия)
          prefix_pat = re.compile(r"^(?P<ver>\d+)_.+\.sql$")

          # формат для миграций:
          # <YY><Major(1-3)><Minor(2)><Hotfix(2)><MM><DD><HH><mm><ss>_desc.sql
          strict_new_pat = re.compile(
            r"^(?P<yy>\d{2})(?P<major>\d{1,3})(?P<minor>\d{2})(?P<hf>\d{2})"
            r"(?P<MM>(0[1-9]|1[0-2]))(?P<DD>(0[1-9]|[12]\d|3[01]))(?P<HH>([01]\d|2[0-3]))(?P<mm>([0-5]\d))(?P<ss>([0-5]\d))"
            r"_.+\.sql$"
          )

          def sh(cmd):
              return subprocess.check_output(cmd, text=True).strip()

          def fail(msg: str):
              print(f"::error::{msg}")
              sys.exit(1)

          def git_ls(ref: str):
              cmd = ["git", "ls-tree", "-r", "--name-only", ref, "--", MIG_DIR]
              out = subprocess.check_output(cmd, text=True).splitlines()
              return [p for p in out if p.endswith(".sql")]

          def version_from_path(p: str):
              name = os.path.basename(p)
              m = prefix_pat.match(name)
              if not m:
                  return None
              return int(m.group("ver"))

          # ---- DIAGNOSTICS: общая инфа про ран ----
          print("=== DIAG: GitHub context ===")
          print("GITHUB_EVENT_NAME:", os.environ.get("GITHUB_EVENT_NAME"))
          print("GITHUB_REF:", os.environ.get("GITHUB_REF"))
          print("GITHUB_HEAD_REF:", os.environ.get("GITHUB_HEAD_REF"))
          print("GITHUB_BASE_REF:", os.environ.get("GITHUB_BASE_REF"))
          print("GITHUB_SHA:", os.environ.get("GITHUB_SHA"))

          print("\n=== DIAG: repo state ===")
          print("HEAD commit:", sh(["git", "rev-parse", "HEAD"]))
          try:
              print("HEAD branch:", sh(["git", "rev-parse", "--abbrev-ref", "HEAD"]))
          except Exception:
              pass

          base_ref_name = os.environ.get("GITHUB_BASE_REF")
          if not base_ref_name:
              fail("Этот workflow предназначен для событий pull_request (GITHUB_BASE_REF пуст).")

          # Подтягиваем целевую ветку
          subprocess.check_call(["git", "fetch", "origin", base_ref_name, "--depth=1"])
          base_ref = f"origin/{base_ref_name}"

          print("\n=== DIAG: base/head refs ===")
          print("base_ref:", base_ref, "->", sh(["git", "rev-parse", base_ref]))
          print("head_ref(HEAD):", sh(["git", "rev-parse", "HEAD"]))

          base_files = git_ls(base_ref)
          head_files = git_ls("HEAD")

          print("\n=== DIAG: files counts ===")
          print("base_files:", len(base_files))
          print("head_files:", len(head_files))

          base_set, head_set = set(base_files), set(head_files)

          # Запрет удаления/переименования (файлы из base должны существовать в PR)
          missing = sorted(base_set - head_set)
          print("\n=== DIAG: missing (base - head) ===")
          print("missing_count:", len(missing))
          if len(missing) > 0:
              print("missing_sample:", missing[:20])

          if missing:
              fail("PR удаляет/переименовывает существующие миграции из целевой ветки: " +
                   ", ".join(missing[:20]) + ("..." if len(missing) > 20 else ""))

          # Выделяем новые миграции
          new_files = sorted(head_set - base_set)
          print("\n=== DIAG: new_files (head - base) ===")
          print("new_files_count:", len(new_files))
          if len(new_files) > 0:
              print("new_files_sample:", new_files[:50])

          # ---- DIAGNOSTICS: max(base) и top версий ----
          def collect_versions(files, label):
              vs = []
              bad = []
              for p in files:
                  v = version_from_path(p)
                  if v is None:
                      bad.append(os.path.basename(p))
                  else:
                      vs.append((v, os.path.basename(p)))
              vs.sort(key=lambda x: x[0])
              print(f"\n=== DIAG: versions in {label} ===")
              print("bad_prefix_count:", len(bad))
              if bad:
                  print("bad_prefix_sample:", bad[:10])
              print("min_version:", vs[0][0] if vs else None)
              print("max_version:", vs[-1][0] if vs else None)
              print("top5_max:")
              for v, n in reversed(vs[-5:]):
                  print(" ", v, n)
              return vs, bad

          base_vs, base_bad = collect_versions(base_files, "base")
          head_vs, head_bad = collect_versions(head_files, "head")

          if base_bad:
              fail("Имя файла миграции в целевой ветке должно начинаться с цифр и затем содержать подчёркивание: " + ", ".join(base_bad[:10]))

          # Максимальная версия в base
          base_max = base_vs[-1][0] if base_vs else -1
          print("\n=== DIAG: base_max ===")
          print("base_max:", base_max)

          # ---- Проверка формата имён для новых миграций ----
          bad = []
          print("\n=== DIAG: strict format check for new_files ===")
          for p in new_files:
              n = os.path.basename(p)

              m_prefix = prefix_pat.match(n)
              v = int(m_prefix.group("ver")) if m_prefix else None

              ok = strict_new_pat.match(n) is not None
              print(f" - {n} | version={v} | strict_ok={ok}")

              if not ok:
                  bad.append(n)

          if bad:
              fail("Новые миграции должны соответствовать формату: <YY><Major(1-3)><Minor(2)><Hotfix(2)><MM><DD><HH><mm><ss>_desc.sql. Ошибки: " +
                   ", ".join(bad[:20]) + ("..." if len(bad) > 20 else ""))

          # ---- Дубликаты версий в PR-ветке ----
          seen = {}
          for p in head_files:
              v = version_from_path(p)
              if v is None:
                  fail(f"Имя файла миграции должно начинаться с цифр и затем содержать подчёркивание: {os.path.basename(p)}")
              seen[v] = seen.get(v, 0) + 1
          dups = [v for v, c in seen.items() if c > 1]
          print("\n=== DIAG: duplicates ===")
          print("dups_count:", len(dups))
          if dups:
              print("dups_sample:", sorted(dups)[:20])
              fail("Найдены дубликаты версий миграций в PR-ветке: " + ", ".join(map(str, sorted(dups)[:20])))

          # ---- Проверка порядка: новые версии строго больше max(base) ----
          offenders = []
          print("\n=== DIAG: order check (new > base_max) ===")
          for p in new_files:
              v = version_from_path(p)
              if v is None:
                  continue
              if v <= base_max:
                  offenders.append(f"{os.path.basename(p)} ({v})")
                  print(" OFFENDER:", os.path.basename(p), v, "<= base_max", base_max)

          if offenders:
              fail(f"Версии новых миграций должны быть > max(base) ({base_max}). Нарушители: " +
                   ", ".join(offenders[:20]) + ("..." if len(offenders) > 20 else ""))

          print(f"\nOK. max(base)={base_max}, новых миграций={len(new_files)}")
          PY
